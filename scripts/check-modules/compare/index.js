#!/usr/bin/env node

import {Command} from "commander";
import {exec} from "node:child_process";
import {fileURLToPath} from "node:url";
import fsPromises from "node:fs/promises";
import path from "node:path";
import {performDiff} from "./diff.js";
import process from "node:process";
import {promisify} from "node:util";

const currentFile = fileURLToPath(import.meta.url);
const currentDir = path.dirname(currentFile);
const PROJECT_ROOT = path.resolve(currentDir, "..", "..", "..");
const DEFAULT_FIXTURE_DIR = path.join(PROJECT_ROOT, "fixtures", "modules");
const DEFAULT_OUTPUT_DIR = path.join(PROJECT_ROOT, ".pipeline-runs", "compare");
const DEFAULT_LEGACY_COMMAND = "skip";
const DEFAULT_TS_COMMAND = "node scripts/orchestrator/index.js run --only=check-modules";
const MAX_BUFFER_BYTES = 20 * 1024 * 1024;
const {access, copyFile, mkdir, writeFile} = fsPromises;
const execAsync = promisify(exec);
const PIPELINE_ARTIFACTS = [
  {id: "modules.stage.5.json", path: "fixtures/data/modules.stage.5.json"},
  {id: "modules.json", path: "fixtures/data/modules.json"},
  {id: "stats.json", path: "fixtures/data/stats.json"}
];

function resolvePath (candidate, fallback) {
  if (!candidate) {
    return fallback;
  }

  if (path.isAbsolute(candidate)) {
    return candidate;
  }

  return path.resolve(PROJECT_ROOT, candidate);
}

async function ensurePathExists (targetPath) {
  try {
    await access(targetPath);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Required path not found: ${targetPath}\n${message}`, {cause: error});
  }
}

async function ensureOutputDirectory (outputRoot, runId) {
  const target = path.join(outputRoot, runId);
  await mkdir(target, {recursive: true});
  return target;
}

function createInitialPlan ({fixturesPath, legacyCommand, tsCommand, runId, runDirectory}) {
  return {
    status: "pending-execution",
    createdAt: new Date().toISOString(),
    fixturesPath,
    commands: {
      legacy: legacyCommand,
      ts: tsCommand
    },
    runId,
    runDirectory,
    runs: [],
    notes: [
      "Harness captures outputs for the configured runs and diffs their Stage 5 artifacts when more than one command executes.",
      "Provide --legacy if you want to compare against an alternate implementation."
    ]
  };
}

async function writePlanJson (directory, plan) {
  const summaryPath = path.join(directory, "plan.json");
  await writeFile(summaryPath, `${JSON.stringify(plan, null, 2)}\n`, "utf8");
  return summaryPath;
}

async function writePlanReadme (directory) {
  const readmePath = path.join(directory, "README.md");
  const readmeContents = [
    "# check-modules comparison harness",
    "",
    "This directory was generated by the comparison harness CLI. It",
    "captures stdout/stderr alongside selected Stage 5 artifacts for each",
    "configured run and, when at least two commands execute, diffs the",
    "captured outputs.",
    "",
    "## Generated files",
    "",
    "- `plan.json` — metadata about executed commands and captured artifacts.",
    "- Per-run directories (e.g. `legacy/`, `ts/`) with logs and copied artifacts.",
    "- `diff.json`, `diff.md` — summaries of comparison results when a diff occurs.",
    "",
    "## Notes",
    "",
    "- By default the legacy command is skipped. Pass `--legacy <command>`",
    "  to compare against another implementation.",
    "- Decide on failure thresholds for mismatches and integrate into CI.",
    ""
  ].join("\n");
  await writeFile(readmePath, `${readmeContents}\n`, "utf8");
  return readmePath;
}

function isSkippedCommand (command) {
  const normalized = typeof command === "string" ? command.trim().toLowerCase() : "";
  return normalized.length === 0 || normalized === "skip";
}

async function copyPipelineArtifacts (stepDir, artifacts) {
  const artifactDir = path.join(stepDir, "artifacts");
  await mkdir(artifactDir, {recursive: true});

  const captured = [];
  const missing = [];

  for (const artifact of artifacts) {
    const source = path.join(PROJECT_ROOT, artifact.path);
    const target = path.join(artifactDir, artifact.id);
    try {
      await copyFile(source, target);
      captured.push({
        id: artifact.id,
        source: artifact.path,
        relativePath: path.relative(stepDir, target)
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      missing.push({
        id: artifact.id,
        source: artifact.path,
        error: message
      });
    }
  }

  return {captured, missing, artifactDir};
}

async function executePipeline (label, command, runDirectory) {
  const stepDir = path.join(runDirectory, label);
  await mkdir(stepDir, {recursive: true});

  if (isSkippedCommand(command)) {
    console.log(`[compare] ${label} command skipped.`);
    return {
      label,
      command,
      exitCode: null,
      skipped: true,
      capturedArtifacts: [],
      missingArtifacts: [],
      stdoutPath: null,
      stderrPath: null,
      artifactsDir: null,
      startedAt: null,
      finishedAt: null,
      durationMs: null
    };
  }

  const startedAt = new Date();
  let stdout;
  let stderr;
  let exitCode = 0;
  let errorMessage;

  try {
    const result = await execAsync(command, {
      cwd: PROJECT_ROOT,
      maxBuffer: MAX_BUFFER_BYTES
    });
    stdout = result.stdout ?? "";
    stderr = result.stderr ?? "";
  } catch (error) {
    exitCode = typeof error?.code === "number" ? error.code : 1;
    stdout = error.stdout ?? "";
    stderr = error.stderr ?? "";
    errorMessage = error instanceof Error ? error.message : String(error);
  }

  const stdoutPath = path.join(stepDir, "stdout.log");
  const stderrPath = path.join(stepDir, "stderr.log");
  await writeFile(stdoutPath, stdout ?? "", "utf8");
  await writeFile(stderrPath, stderr ?? "", "utf8");

  const {captured, missing, artifactDir} = await copyPipelineArtifacts(stepDir, PIPELINE_ARTIFACTS);

  if (exitCode === 0) {
    console.log(`[compare] ${label} command completed (exit 0).`);
  } else {
    console.error(`[compare] ${label} command exited with code ${exitCode}`);
    if (errorMessage) {
      console.error(`[compare] ${label} error: ${errorMessage}`);
    }
  }

  if (missing.length > 0) {
    const missingList = missing.map((item) => item.id).join(", ");
    console.warn(`[compare] ${label} missing artifacts: ${missingList}`);
  }

  const finishedAt = new Date();

  return {
    label,
    command,
    exitCode,
    skipped: false,
    startedAt: startedAt.toISOString(),
    finishedAt: finishedAt.toISOString(),
    durationMs: finishedAt.getTime() - startedAt.getTime(),
    stdoutPath: path.relative(runDirectory, stdoutPath),
    stderrPath: path.relative(runDirectory, stderrPath),
    artifactsDir: path.relative(runDirectory, artifactDir),
    capturedArtifacts: captured,
    missingArtifacts: missing
  };
}

async function runCli () {
  const program = new Command();

  program
    .name("check-modules:compare")
    .description("Compare outputs between Stage 5 runs using the curated fixtures (diff harness).")
    .option("--fixtures <path>", "Path to the curated module fixtures", DEFAULT_FIXTURE_DIR)
    .option("--legacy <command>", "Command used to run the legacy pipeline", DEFAULT_LEGACY_COMMAND)
    .option("--ts <command>", "Command used to run the TypeScript pipeline", DEFAULT_TS_COMMAND)
    .option("--output <path>", "Directory to store comparison artifacts", DEFAULT_OUTPUT_DIR)
    .option("--run-id <id>", "Identifier for this comparison run", () => `run-${Date.now()}`)
    .action(async (options) => {
      const fixturesPath = resolvePath(options.fixtures, DEFAULT_FIXTURE_DIR);
      const outputRoot = resolvePath(options.output, DEFAULT_OUTPUT_DIR);
      const legacyCommand = options.legacy ?? DEFAULT_LEGACY_COMMAND;
      const tsCommand = options.ts ?? DEFAULT_TS_COMMAND;
      const runId = typeof options.runId === "function" ? options.runId() : options.runId ?? `run-${Date.now()}`;

      await ensurePathExists(fixturesPath);
      await mkdir(outputRoot, {recursive: true});
      const runDirectory = await ensureOutputDirectory(outputRoot, runId);

      const plan = createInitialPlan({
        fixturesPath,
        legacyCommand,
        tsCommand,
        runId,
        runDirectory
      });
      await writePlanReadme(runDirectory);
      const summaryPath = await writePlanJson(runDirectory, plan);

      console.log(`[compare] Prepared run directory: ${runDirectory}`);
      console.log(`[compare] Summary written to: ${summaryPath}`);

      const pipelines = [
        {label: "legacy", command: legacyCommand},
        {label: "ts", command: tsCommand}
      ];

      const results = [];

      for (const pipeline of pipelines) {
        const result = await executePipeline(pipeline.label, pipeline.command, runDirectory);
        plan.runs.push(result);
        results.push(result);
      }

      const hasFailure = results.some((run) => run.skipped === false && typeof run.exitCode === "number" && run.exitCode !== 0);
      const hasMissingArtifacts = results.some((run) => (run.missingArtifacts ?? []).length > 0);
      const hasSkipped = results.some((run) => run.skipped);
      const executedRuns = results.filter((run) => run.skipped === false);
      const allSkipped = executedRuns.length === 0;

      const notes = [];

      if (hasFailure) {
        plan.status = "execution-failed";
        notes.push("One or more commands exited with a non-zero code. Inspect stdout/stderr logs for details.");
        process.exitCode = 1;
        plan.diff = {status: "not-run"};
      } else if (allSkipped) {
        plan.status = "not-run";
        notes.push("All commands were skipped. Provide at least one command to execute before diffing.");
        plan.diff = {status: "not-run"};
      } else if (hasSkipped) {
        plan.status = "ts-only";
        notes.push("Some commands were skipped (e.g. the legacy implementation), so no diff was generated. Pass --legacy <command> to compare against another run.");
        plan.diff = {status: "not-run"};
      } else {
        const diffOutcome = await performDiff({runDirectory, results});
        const diffInfo = {
          status: diffOutcome.status,
          summaryPath: diffOutcome.summaryPath ? path.relative(runDirectory, diffOutcome.summaryPath) : null,
          markdownPath: diffOutcome.markdownPath ? path.relative(runDirectory, diffOutcome.markdownPath) : null,
          summary: diffOutcome.summary ?? null
        };
        if (diffOutcome.reason) {
          diffInfo.reason = diffOutcome.reason;
        }
        plan.diff = diffInfo;

        if (diffOutcome.status === "matched") {
          plan.status = "diff-matched";
          notes.push("Legacy and TypeScript outputs match for evaluated artifacts.");
        } else if (diffOutcome.status === "differences") {
          plan.status = "diff-differences";
          notes.push("Differences detected between legacy and TypeScript outputs. Review diff.md for details.");
          process.exitCode = 1;
        } else if (diffOutcome.status === "error") {
          plan.status = "diff-error";
          notes.push(diffOutcome.reason ?? "Diff failed due to missing artifacts.");
          process.exitCode = 1;
        } else {
          plan.status = "pending-diff";
          notes.push(diffOutcome.reason ?? "Diff was skipped. Rerun once both commands succeed.");
        }
      }

      if (!hasFailure && hasMissingArtifacts) {
        notes.push("Some expected artifacts were missing; see run details for specifics.");
      }

      plan.notes = notes;

      if (!plan.diff) {
        plan.diff = {status: "not-run"};
      }

      const updatedSummaryPath = await writePlanJson(runDirectory, plan);
      console.log(`[compare] Updated summary written to: ${updatedSummaryPath}`);
    });

  program.showHelpAfterError("(run with --help for usage)");

  try {
    await program.parseAsync(process.argv);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`[compare] Error: ${message}`);
    process.exitCode = 1;
  }
}

runCli();
