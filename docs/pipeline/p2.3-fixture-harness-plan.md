# P2.3 Fixture Comparison Harness Plan

_Last updated: October 1, 2025_

## Status

- [x] Harness CLI executes legacy/TS commands, captures artifacts, and computes diffs.
- [x] CI workflow (`check-modules-compare.yaml`) runs weekly and on-demand, uploading run artifacts.
- [ ] Follow-ups: extend diffing to README/HTML artifacts and define warning/failure thresholds.

Purpose: define the test harness that compares outputs from the legacy Python `check_modules.py` stage and the now-default TypeScript implementation. The harness ensures the shipped TS stage maintains parity as new checks are introduced.

## 1. Goals

- Run both implementations against the same curated module set.
- Produce structured, diff-able outputs (JSON + Markdown, stats).
- Surface rule-level differences (missing, extra, modified issues) with actionable context.
- Integrate into CI as an optional job (`--checks=compare`) ahead of the Phase 3 cutover.

## 2. Inputs

| Input                   | Description                                                                   | Notes                                                  |
| ----------------------- | ----------------------------------------------------------------------------- | ------------------------------------------------------ |
| Fixture pipeline config | A trimmed stage graph that stops after Stage 5 for a curated dataset.         | Existing fixture pipeline (`scripts/fixtures/`).       |
| Module fixtures         | Small set of repositories or synthetic mocks exercising key rules.            | Selected in coordination with rule inventory (see §5). |
| Legacy stage binary     | Python `check_modules.py` executed via orchestrator (`--checks=legacy`).      | Retained solely for comparisons.                       |
| TS stage binary         | TypeScript implementation executed via `node scripts/check-modules/index.ts`. | Orchestrator default as of Oct 2025.                   |

## 3. Harness Flow

1. **Prepare fixtures:** copy curated modules into a temporary workspace (reuse `fixtures/` tooling where possible).
2. **Run legacy stage:** execute orchestrator with `--only=check-modules --checks=legacy` and capture `modules.stage.5.json`, stats, and README markdown.
3. **Run TS stage:** execute orchestrator with the default (`--only=check-modules` or `--checks=ts`) writing to a separate output directory.
4. **Normalize outputs:** sort arrays, remove timestamp fields when comparing, but keep stats for reporting.
5. **Diff results:**

- Compare Stage 5 module issues per module/rule (strings) and summarize additions/removals.
- Compare aggregate stats (module count, issues count, hoster breakdown) ignoring timestamps.
- Emit machine-readable (`diff.json`) and Markdown (`diff.md`) summaries in the run directory.

6. **Report:** include the diff metadata in `plan.json` and surface exit codes based on differences.
7. **Exit codes:** fail the harness when differences exist or the diff step errors; succeed only when parity holds for the evaluated artifacts.

## 4. Implementation Notes

- Harness lives under `scripts/check-modules/compare/` with reusable helpers.
- The CLI (`node scripts/check-modules/compare/index.js`) prepares a comparison run directory, executes the configured legacy/TS commands (use `--legacy/--ts skip` to bypass), captures stdout/stderr logs, copies the curated Stage 5 artifacts into per-run folders documented in `plan.json`, and runs the diff step producing `diff.json` + `diff.md`.
- Use shared `logger` for consistent output.
- Provide CLI arguments:
  - `--fixtures <path>` to point at a fixture dataset.
  - `--legacy <path>` / `--ts <path>` to override stage commands (for local experimentation).
  - `--output <dir>` for diff reports.
- Include snapshots of expected diffs for the curated fixtures to guard against regressions in the harness itself.

## 5. Fixture Selection Strategy

- **Coverage:** ensure at least one module triggers each rule category (Deprecated, Recommendation, Typo, Outdated).
- **Edge cases:** include modules with:
  - Nested `node_modules` directories.
  - Missing README sections.
  - Use of CDN assets.
  - ESLint/deprecation helper hits.
- **Synthetic modules:** where real examples are unavailable, craft minimal fixture repositories under `fixtures/modules/` to exercise specific rules.
- **Version control:** snapshot fixture repos to known commits to avoid drift.

## 6. CI Integration

- Add a new npm script `checkModules:compare` invoking the harness with the curated fixture set.
- Run the harness in CI via `.github/workflows/check-modules-compare.yaml`, which supports manual dispatch and a weekly schedule; upload the generated run directory for inspection.
- Require green harness runs before flipping the orchestrator default to TS.

## 7. Open Questions

- Do we need a golden file for the README diff, or is a textual summary sufficient?
- How do we threshold acceptable differences (e.g. warning vs failure) when rules intentionally diverge?
- Should the harness support partial rule subsets to accelerate debugging?

---

Next actions: expand coverage to include README/HTML artifact comparisons if needed for downstream confidence, and evaluate thresholds (warnings vs failures) once real fixture diffs are available.
